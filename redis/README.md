redisのパフォーマンス・チューニング詳細
========

Detail
========
TCP接続を確立、切断を毎回やるのでは非効率であると
考えられるためこのオプションを有効にする。
30分間クライアントが断続的に通信する場合、1800に設定
してもいい気がするが、そのクライアントが遅い場合、
バッファを圧迫しかねないので60(推奨値)にしておく
    tcp-keepalive 60

ログは開発版では多くの情報を含ませたほうが構築、ベンチマークがしやすい
    loglevel debug

スナップショットを作らない。bgsaveはプロセスを新しく立てて
行うのでCPU負荷がかかる。オンメモリの動作を期待するならこれを
切る
    save ""

基本的にスナップショットを取らないが、レプリケーションを作成する
際、一回はスナップショットを作成してレプリケーションに流すので
その時、エラーが発生しても動作を止めない。
例えば、フェイルオーバーした後に落ちたredisを再びレプリに参加
させようとした場合、Pub/Subだけで使っている場合、不整合しても
影響がないので動作を続けさせる
    stop-writes-on-bgsave-error no

レプリケーションに再び参加する時にCPUパワーを節約したい。
なのでファイルのチェックサムを切る。同時に圧縮もオフにする。
その分メモリを使う可能性がある。要検証
    rdbchecksum no
    rdbcompression yes

レプリケーションが正常でない場合、エラーを返す。想定している
リアルタイムなオンメモリ通信で、データが即剤に捨てられるような場合
ではこれをyesにするが、redis-sentinelによるmasterが常に存在する
運用を考えるので,今回はnoを設定する
    slave-serve-stale-data no

レプリケーションが生きているかどうかを5sec毎にチェックする。
60秒応答がなければ異常とみなす
    repl-ping-slave-period 5
    repl-timeout 60

yes -> パケットが増えるがslaveのデータ使用可能になるまで時間がかかる
no -> パケットが減り、データ使用可能まで時間が短い
高トラフィックな場合はこれをyesにする
    repl-disable-tcp-nodelay yes

レプリケーションのバックログサイズ。部分的に同期がかかる差分領域。
これ以下のデータ差分の場合、レプリケーションはほぼ負荷がなく(完全同期しない)
でレプリケーションに参加できる
    repl-backlog-size 128mb

30分間スレーブから応答がない場合、このバックログを開放する
    repl-backlog-ttl 1800

ファイルディスクリプタ。OSのシステム設定に制約を受けるが、コネクションの制限を50000まで上げる。理論上50000人さばける。
ulimit -n の数値を動的に書き換えるが、システムの制約自体を超えることはないので、各OSで設定してください
    maxclients 50000

redisが使えるメモリの容量。これもハードウェアに合わせて設定する。レプリケーションのバックログ分は別に容量を取るので、その分減らしてください
    maxmemory 300mb

メモリを節約するためのアルゴリズム。古いものから削除する。これはデフォルトですが、場合によっては変更する
    maxmemory-policy volatile-lru
    maxmemory-samples 3


TODO
======
slow-logを記録するのにI/Oがかかりそうなのであえてスロウクエリを出さない設定もありかもしれない
redis 2.8以降ではPUB/SUBを使ってキーイベントを通知できるらしい。要調査。
list型をziplist圧縮するかどうか(メモリの節約)

MIT License.

*Author: Yoshiya Ito <ito_yoshiya@cyberagent.co.jp>*
